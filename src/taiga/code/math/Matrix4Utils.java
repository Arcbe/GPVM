/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

package taiga.code.math;

/**
 * A collection of method for creating various types of {@link Matrix4}s
 * or apply transformation to existing {@link Matrix4}.
 * 
 * @author Russell Smith
 */
public class Matrix4Utils {
  
  public static Matrix4 lookAt(ReadableVector3 eye, ReadableVector3 up, ReadableVector3 dir, Matrix4 out) {
    return lookAt(eye.getX(), eye.getY(), eye.getZ(), up.getX(), up.getY(), up.getZ(), dir.getX(), dir.getY(), dir.getZ(), out);
  }
  
  public static Matrix4 lookAt(float eyex, float eyey, float eyez, float upx, float upy, float upz, float dirx, float diry, float dirz, Matrix4 out) {
    
    //normalize the direction and set row 2.
    float factor = 1f / (float) Math.sqrt(dirx * dirx + diry * diry + dirz * dirz);
    dirx *= factor;
    diry *= factor;
    dirz *= factor;
    
    out.setValue(2, 0, dirx);
    out.setValue(2, 1, diry);
    out.setValue(2, 2, dirz);
    
    float ux = diry * upz - upy * dirz;
    float uy = upx * dirz - dirx * upz;
    float uz = dirx * upy - upx * diry;
    
    factor = 1f / (float) Math.sqrt(ux * ux + uy * uy + uz * uz);
    ux *= factor;
    uy *= factor;
    uz *= factor;
    
    out.setValue(0, 0, ux);
    out.setValue(0, 1, uy);
    out.setValue(0, 2, uz);
    
    upx = uy * dirz - diry * uz;
    upy = dirx * uz - ux * dirz;
    upz = ux * diry - dirx * uy;
    
    out.setValue(1, 0, upx);
    out.setValue(1, 1, upy);
    out.setValue(1, 2, upz);
    
    out.setValue(0, 3, eyex);
    out.setValue(1, 3, eyey);
    out.setValue(2, 3, eyez);
    
    return out;
  }
  
  public static Matrix4 mLookAt(ReadableVector3 eye, ReadableVector3 up, ReadableVector3 direction, Matrix4 mat) {
    return mat.mul(lookAt(eye, up, direction, new Matrix4()), mat);
  }
  
  /**
   * Multiplies the given {@link Matrix4} by a perspective {@link Matrix4} 
   * generated by the method {@link #perspective(float, float, float, float, taiga.code.math.Matrix4) }.
   * The multiplication will be a post multiplication of the generated {@link Matrix4}.
   * 
   * @param fovy The field of view in radians of the y direction.
   * @param aspect the aspect ratio for the transformation, the width over the height.
   * @param near The coordinate of the near plane, this must not be 0.
   * @param far The coordinate of the far plane.
   * @param mat The {@link Matrix4} to apply the transformation to.
   * @return A reference to the target {@link Matrix4}.
   */
  public static Matrix4 mPerspective(float fovy, float aspect, float near, float far, Matrix4 mat) {
    return mat.mul(perspective(fovy, aspect, near, far, new Matrix4()));
  }
  
  /**
   * Creates a perspective {@link Matrix4} that can be used for 3D graphics.
   * 
   * @param fovy The field of view in radians of the y direction.
   * @param aspect the aspect ratio for the transformation, the width over the height.
   * @param near The coordinate of the near plane, this must not be 0.
   * @param far The coordinate of the far plane.
   * @param out The {@link Matrix4} to store the result in.
   * @return A reference to the out parameter.
   */
  public static Matrix4 perspective(float fovy, float aspect, float near, float far, Matrix4 out) {
    float f = near * (float) Math.tan(fovy / 2);
    
    return frustum(-f / aspect, f / aspect, -f, f, near, far, out);
  }
  
  
  /**
   * Multiplies the given {@link Matrix4} by the {@link Matrix4} generated
   * by the method {@link #frustum(float, float, float, float, float, float, taiga.code.math.Matrix4) }.
   * The multiplication will be a post-multiplication of the generated {@link Matrix4}.
   * 
   * @param left The left clipping pane.
   * @param right The right clipping pane.
   * @param bottom The bottom clipping plane.
   * @param top The top clipping plane.
   * @param near The near clipping plane.
   * @param far The far clipping plane.
   * @param mat The {@link Matrix4} that this transformation will be applied to.
   * @return A reference to the target {@link Matrix4}.
   */
  public static Matrix4 mFrustum(float left, float right, float bottom, float top, float near, float far, Matrix4 mat) {
    return mat.mul(frustum(left, right, bottom, top, near, far, new Matrix4()));
  }
  
  /**
   * Creates a {@link Matrix4} that projects a frustum onto the unit square
   * in homogenous coordinates. Each clipping pane is the coordinate of the
   * respective side at the near clipping plane.  This frustum is centered on the
   * positive z axis.
   * 
   * @param left The left clipping pane.
   * @param right The right clipping pane.
   * @param bottom The bottom clipping plane.
   * @param top The top clipping plane.
   * @param near The near clipping plane.
   * @param far The far clipping plane.
   * @param out The {@link Matrix4} that the results will be written to.
   * @return A reference to the out parameter.
   */
  public static Matrix4 frustum(float left, float right, float bottom, float top, float near, float far, Matrix4 out) {
    out.values[0][0] = 2 * near / (right - left);
    out.values[0][1] = 0;
    out.values[0][2] = (left + right) / (right - left);
    out.values[0][3] = 0;
    
    out.values[1][0] = 0;
    out.values[1][1] = 2 * near / (top - bottom);
    out.values[1][2] = (top + bottom) / (top - bottom);
    out.values[1][3] = 0;
    
    out.values[2][0] = 0;
    out.values[2][1] = 0;
    out.values[2][2] = - (far + near) / (far - near);
    out.values[2][3] = -2 * far * near / (far - near);
    
    out.values[3][0] = 0;
    out.values[3][1] = 0;
    out.values[3][2] = -1;
    out.values[3][3] = 0;
    
    return out;
  }
  
  /**
   * Sets the given matrix to a scaling matrix.
   * 
   * @param x The amount to scale the x axis.
   * @param y The amount to scale the y axis.
   * @param z The amount to scale the z axis.
   * @param out The {@link Matrix4} to store the result in.
   * @return A reference to the out parameter.
   */
  public static Matrix4 scaling(float x, float y, float z, Matrix4 out) {
    out.values[0][0] = x;
    out.values[1][1] = y;
    out.values[2][2] = z;
    
    out.values[0][1] = 0;
    out.values[0][2] = 0;
    out.values[0][3] = 0;
    out.values[1][0] = 0;
    out.values[1][2] = 0;
    out.values[1][3] = 0;
    out.values[2][0] = 0;
    out.values[2][1] = 0;
    out.values[2][3] = 0;
    out.values[3][0] = 0;
    out.values[3][1] = 0;
    out.values[3][2] = 0;
    out.values[3][3] = 1;
    
    return out;
  }
}
