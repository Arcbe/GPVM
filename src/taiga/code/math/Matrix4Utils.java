/*
 * Copyright (C) 2014 Russell Smith.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.0 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
 * MA 02110-1301  USA
 */

package taiga.code.math;

/**
 * A collection of method for creating various types of {@link Matrix4}s
 * or apply transformation to existing {@link Matrix4}.
 * 
 * @author Russell Smith
 */
public class Matrix4Utils {
  
  public static Matrix4 lookAt(ReadableVector3 eye, ReadableVector3 up, ReadableVector3 dir, Matrix4 out) {
    return lookAt(eye.getX(), eye.getY(), eye.getZ(), up.getX(), up.getY(), up.getZ(), dir.getX(), dir.getY(), dir.getZ(), out);
  }
  
  public static Matrix4 lookAt(float eyex, float eyey, float eyez, float upx, float upy, float upz, float dirx, float diry, float dirz, Matrix4 out) {
    
    //normalize the direction and set row 2.
    float factor = 1f / (float) Math.sqrt(dirx * dirx + diry * diry + dirz * dirz);
    dirx *= factor;
    diry *= factor;
    dirz *= factor;
    
    out.setValue(2, 0, -dirx);
    out.setValue(2, 1, -diry);
    out.setValue(2, 2, -dirz);
    
    float ux = upy * dirz - diry * upz;
    float uy = dirx * upz - upx * dirz;
    float uz = upx * diry - dirx * upy;
    
    factor = 1f / (float) Math.sqrt(ux * ux + uy * uy + uz * uz);
    ux *= factor;
    uy *= factor;
    uz *= factor;
    
    out.setValue(0, 0, ux);
    out.setValue(0, 1, uy);
    out.setValue(0, 2, uz);
    
    upx = diry * uz - uy * dirz;
    upy = ux * dirz - dirx * uz;
    upz = dirx * uy - ux * diry;
    
    out.setValue(1, 0, upx);
    out.setValue(1, 1, upy);
    out.setValue(1, 2, upz);
    
    float ex = 
      out.getValue(0, 0) * eyex +
      out.getValue(0, 1) * eyey +
      out.getValue(0, 2) * eyez;
    float ey = 
      out.getValue(1, 0) * eyex +
      out.getValue(1, 1) * eyey +
      out.getValue(1, 2) * eyez;
    float ez = 
      out.getValue(2, 0) * eyex +
      out.getValue(2, 1) * eyey +
      out.getValue(2, 2) * eyez;
    
    out.setValue(0, 3, -ex);
    out.setValue(1, 3, -ey);
    out.setValue(2, 3, -ez);
    
    return out;
  }
  
  public static Matrix4 mLookAt(ReadableVector3 eye, ReadableVector3 up, ReadableVector3 direction, Matrix4 mat) {
    return mat.mul(lookAt(eye, up, direction, new Matrix4()), mat);
  }
  
  /**
   * Multiplies the given {@link Matrix4} by a perspective {@link Matrix4} 
   * generated by the method {@link #perspective(float, float, float, float, taiga.code.math.Matrix4) }.
   * The multiplication will be a post multiplication of the generated {@link Matrix4}.
   * 
   * @param fovy The field of view in radians of the y direction.
   * @param aspect the aspect ratio for the transformation, the width over the height.
   * @param near The coordinate of the near plane, this must not be 0.
   * @param far The coordinate of the far plane.
   * @param mat The {@link Matrix4} to apply the transformation to.
   * @return A reference to the target {@link Matrix4}.
   */
  public static Matrix4 mPerspective(float fovy, float aspect, float near, float far, Matrix4 mat) {
    return mat.mul(perspective(fovy, aspect, near, far, new Matrix4()));
  }
  
  /**
   * Creates a perspective {@link Matrix4} that can be used for 3D graphics.
   * 
   * @param fovy The field of view in radians of the y direction.
   * @param aspect the aspect ratio for the transformation, the width over the height.
   * @param near The coordinate of the near plane, this must not be 0.
   * @param far The coordinate of the far plane.
   * @param out The {@link Matrix4} to store the result in.
   * @return A reference to the out parameter.
   */
  public static Matrix4 perspective(float fovy, float aspect, float near, float far, Matrix4 out) {
    float f = near * (float) Math.tan(fovy / 2);
    
    return frustum(-f * aspect, f * aspect, -f, f, near, far, out);
  }
  
  
  /**
   * Multiplies the given {@link Matrix4} by the {@link Matrix4} generated
   * by the method {@link #frustum(float, float, float, float, float, float, taiga.code.math.Matrix4) }.
   * The multiplication will be a post-multiplication of the generated {@link Matrix4}.
   * 
   * @param left The left clipping pane.
   * @param right The right clipping pane.
   * @param bottom The bottom clipping plane.
   * @param top The top clipping plane.
   * @param near The near clipping plane.
   * @param far The far clipping plane.
   * @param mat The {@link Matrix4} that this transformation will be applied to.
   * @return A reference to the target {@link Matrix4}.
   */
  public static Matrix4 mFrustum(float left, float right, float bottom, float top, float near, float far, Matrix4 mat) {
    return mat.mul(frustum(left, right, bottom, top, near, far, new Matrix4()));
  }
  
  /**
   * Creates a {@link Matrix4} that projects a frustum onto the unit square
   * in homogenous coordinates. Each clipping pane is the coordinate of the
   * respective side at the near clipping plane.  This frustum is centered on the
   * positive z axis.
   * 
   * @param left The left clipping pane.
   * @param right The right clipping pane.
   * @param bottom The bottom clipping plane.
   * @param top The top clipping plane.
   * @param near The near clipping plane.
   * @param far The far clipping plane.
   * @param out The {@link Matrix4} that the results will be written to.
   * @return A reference to the out parameter.
   */
  public static Matrix4 frustum(float left, float right, float bottom, float top, float near, float far, Matrix4 out) {
    out.values[0][0] = 2 * near / (right - left);
    out.values[0][1] = 0;
    out.values[0][2] = (left + right) / (right - left);
    out.values[0][3] = 0;
    
    out.values[1][0] = 0;
    out.values[1][1] = 2 * near / (top - bottom);
    out.values[1][2] = (top + bottom) / (top - bottom);
    out.values[1][3] = 0;
    
    out.values[2][0] = 0;
    out.values[2][1] = 0;
    out.values[2][2] = - (far + near) / (far - near);
    out.values[2][3] = -2 * far * near / (far - near);
    
    out.values[3][0] = 0;
    out.values[3][1] = 0;
    out.values[3][2] = -1;
    out.values[3][3] = 0;
    
    return out;
  }
  
  /**
   * Sets the given matrix to a scaling matrix.
   * 
   * @param x The amount to scale the x axis.
   * @param y The amount to scale the y axis.
   * @param z The amount to scale the z axis.
   * @param out The {@link Matrix4} to store the result in.
   * @return A reference to the out parameter.
   */
  public static Matrix4 scaling(float x, float y, float z, Matrix4 out) {
    out.values[0][0] = x;
    out.values[1][1] = y;
    out.values[2][2] = z;
    
    out.values[0][1] = 0;
    out.values[0][2] = 0;
    out.values[0][3] = 0;
    out.values[1][0] = 0;
    out.values[1][2] = 0;
    out.values[1][3] = 0;
    out.values[2][0] = 0;
    out.values[2][1] = 0;
    out.values[2][3] = 0;
    out.values[3][0] = 0;
    out.values[3][1] = 0;
    out.values[3][2] = 0;
    out.values[3][3] = 1;
    
    return out;
  }
}
