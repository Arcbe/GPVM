package taiga.gpvm.render;

import gpvm.io.DataNode;
import gpvm.util.StringManager;
import java.lang.ref.WeakReference;
import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * A registry containing {@link TileRenderer} and {@link RenderInfo} for
 * tile ids.
 * 
 * @author russell
 */
public final class RenderRegistry {
  /**
   * An instance of a {@link RenderRegistry} that only contains functions that
   * can read its state.
   */
  public final class ReadOnlyRenderRegistry {
    /**
     * @see RenderRegistry#getEntry(long) 
     * @param tileid
     * @return 
     */
    public RendererEntry getEntry(long tileid) {
      return RenderRegistry.this.getEntry(tileid);
    }
  }
  
  /**
   * A single entry in a {@link RenderRegistry}.
   */
  public static final class RendererEntry {
    //TODO: create a read version of this class.
    
    /**
     * The class of the {@link TileRenderer}used for these tiles.
     */
    public final TileRenderer renderer;
    
    /**
     * Any information for the rendering of a {@link Tile} using this.
     */
    public final RenderInfo info;

    /**
     * Creates a new entry for the {@link RenderRegistry}.
     * 
     * @param renderclass The class of the renderclass for this entry.
     * @param info Any addition rendering information for this entry.  This will
     *            be used to 
     */
    public RendererEntry(Class<? extends TileRenderer> renderclass, DataNode data) throws InstantiationException, IllegalAccessException, NoSuchFieldException {
      //create the renderclass for the tiles if needed.
      if(!renderers.containsKey(renderclass) || renderers.get(renderclass).get() == null) {
        this.renderer = renderclass.newInstance();
        renderers.put(renderclass, new WeakReference<>(this.renderer));
      } else //TODO: possible timing bug here, investigate.
        this.renderer = renderers.get(renderclass).get();
      
      info = populateRenderInfo(renderer.getRenderInfo(), data);
    }
    
    private static RenderInfo populateRenderInfo(Class<? extends RenderInfo> infoclass, DataNode data) throws InstantiationException, IllegalAccessException, NoSuchFieldException {
      //first create the info class
      RenderInfo info = infoclass.newInstance();
      
      for(String val : data.getValues()) {
        Field f;
        try {
          f = infoclass.getDeclaredField(val);
        } catch (NoSuchFieldException | SecurityException ex) {
          log.log(Level.SEVERE, StringManager.getLocalString("err_missing_renderer_field", val, infoclass), ex);
          
          throw ex;
        }
        
        if(data.isType(val, f.getType())) {
          f.set(info, data.getValue(val));
        } else {
          log.log(Level.SEVERE, StringManager.getLocalString("err_wrong_render_field_type", val, infoclass));
        }
      }
      
      return info;
    }
    
    private static HashMap<Class<?>, WeakReference<TileRenderer>> renderers = new HashMap<>();
  }
  
  /**
   * Creates a new empty {@link RenderRegistry}.
   */
  public RenderRegistry() {
    data = new HashMap<>();
    listeners = new ArrayList<>();
  }

  /**
   * Adds a {@link RenderRegistryListener} for events generated by this
   * {@link RenderRegistry}.
   * 
   * @param list The listener to add.
   */
  public void addListener(RenderRegistryListener list) {
    listeners.add(list);
  }
  
  /**
   * Clears all entries from this {@link RenderRegistry}.
   */
  public void clear() {
    data.clear();
    
    fireRegistryCleared();
  }
  
  /**
   * Gets the entry associated with the given TileID.  This id must be the 
   * base id for the tile without any metadata.
   * 
   * @param tileid The id to get the entry for.
   * @return The requested entry r null if there is no associated entry.
   */
  public RendererEntry getEntry(long tileid) {
    return data.get(tileid);
  }
  
  /**
   * Adds an entry to the registry.
   * 
   * @param entry The entry to add.
   * @param tileid The tile id that it is associated with.
   */
  public void addEntry(RendererEntry entry, long tileid) {
    data.put(tileid, entry);
    
    fireEntryAdded(tileid, entry);
  }
  
  private void fireRegistryCleared() {
    for(RenderRegistryListener list : listeners)
      list.registryCleared();
  }
  
  private void fireEntryAdded(long tileid, RendererEntry entry) {
    for(RenderRegistryListener list : listeners)
      list.entryAdded(tileid, entry);
  }
  
  private HashMap<Long, RendererEntry> data;
  private ArrayList<RenderRegistryListener> listeners;
  
  private static final Logger log = Logger.getLogger(RenderRegistry.class.getName());
}
